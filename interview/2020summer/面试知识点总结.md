<!--
 * @Date: 2020-05-20 20:31:15
 * @LastEditors: hanjiawang
 * @LastEditTime: 2021-04-06 11:25:20
-->

# 一轮复习

## 自我介绍

面试官你好，我叫韩嘉旺，21 岁，是今年 6 月份毕业的本科生，我在途牛公司有一年前端工作经验；就职期间我参与研发了两个项目；一个是途牛商旅 app 使用的是 React-Native 技术栈；完成了整体百分之 20 的任务量；另一个是使用基于 vue 的 uni-app 框架研发了途牛商旅的 h5 端、微信小程序端和企业微信端；我喜欢挑战自己，完成较为困难的任务，负责了 h5 端转小程序端，封装了多业务线的日历控件；

## 项目介绍以及准备的点

1. 途牛商旅 h5 端、小程序端、企业微信端：途牛商旅是途牛公司 toB 业务的主要产品，目的是为了让员工出差更方便，途牛商旅内含审批单系统，
   有事前审批 和事中审批两部分，在员工出差时可根据审批单等各种配置来限制审批和出差预算，出行地点等，在支付时可以不用员工 垫付而是由途牛垫付，
   最后一起报销，可以让员工出差更方便，企业在管理上也更加方便。我主要负责了机票酒店火车票的三条业务线开发，机票退票业务，滴滴页面的嵌入等难点如下；
   - watch 的坑，跨页面触发，通过全局变量，destroy
   - 酒店列表页筛选条件，和列表页搜索栏，列表的删除筛选，首页的筛选联动
   - 自带路由问题，vue-router
   - 封装了适配多业务线的日历控件
     - 分析业务需求确定组件入参
       1. 模式（机票往返、机票多程、机票单程、火车、酒店）
       2. 上次选择的开始日期结束日期
       3. 要展示的月份个数
     - 封装组件
       - 计算日期数据
         - 根据入参中的月份个数使用 for 循环遍历，i 从 0 到这个月份，遍历这么多次；先创建月份对象，包含当前月份日期数组、月份、年份；
           创建总的日期渲染数据源数组，存放所有的月份对象；
           先确定当前月份和年份存入月份对象中，再确认这个月有多少天，判断 1 号是星期几，把前面空着的用 null 代替，将数据存入月份对象中的日期数组；
           每个月遍历后，总数据源就确定了；
       - 渲染数据
         - 头部，星期标尺，遍历总日历数据，每月的头部加上年份和月份；
         - 遍历每个月份数据中的日期数据，从头开始排即可
         - 绑定点击事件（获取到具体日期，选完展示确定按钮）
       - 适配不同业务模式 ui
         - 为不同模式适配不同的头部，点击限制逻辑，每个日期部分的展示内容等
       - VueX 做状态管理
         - 点击确定将数据存入 Store 中便于业务线获取时间
   - h5 端转小程序端的一些坑
     - 分包
       - 要求主包分包总大小不能超过 12m，分包大小不能超过 2m
         - 借助 CDN
       - 在 page.json 中配置
     - 分包之间不能引用，主包也不能引用分包
     - v-show 不支持
     - 样式不能用方法返回
     - v-html 不支持
     - 不能使用浏览器自带对象如 document、window 等
     - 选择器支持问题
       - id 选择器，last-child
     - 不能很好的定位 bug，有时页面白屏，没有提示
   - 手机端自适应
     - rpx 微信小程序规定 iphone6 宽度为 750rpx，此时 1px=2rpx，设计稿以 iphone6 为基准进行设计，开发中各种机型自然自适应
   - 性能
     - 使用代码压缩
       - webpack 配置方法
     - 借助 CDN 减少服务器压力
     - 懒加载
     - 去除冗余代码
2. 途牛商旅 app，业务相同；我主要负责了机票酒店火车票的三条业务线开发
   - 适配机型
     - 设计稿 Iphone6，适配 IphoneX 留海屏 statusBar 高度，IphoneX44，往上抬 25
   - 性能处理（shouldComponentUpdate）
3. 途牛商旅总结
   - 机票接口是轮询接口，通过needQueryMore 字段控制

## 面试知识点总结

### CSS

- CSS 的引用
  link 标签和@import
  - 从属关系，link 不仅可以加载 css 还可以设置 RSS，rel 连接属性等，而@import 只能用来导入 css 样式
  - 加载顺序，link 随 dom 加载，@import 则在页面加载完成之后加载
  - dom 操作，link 导入的样式可通过 js 修改，@import 不可
  - 兼容性，@import IE5 之上可用，link 则都支持

- CSS 的优先级
  !important>行内样式>id 选择器>类选择器>标签选择器>通配符选择器>继承属性>默认

- 盒模型
  - content-box:宽高包含内容部分大小
  - border-box:宽高包括内容部分内边距和内边框的大小
  - padding-box:宽高包含内容部分和内边距大小
  - margin-box:宽高包含内容内边距内边框和外边距

- display=none 和 visibility=hidden 的区别
  display 不占用文档流，visibility 占用文档流
  继承，父类 display=none 子类必被隐藏，而父类 visibility 设置 hidden，子类设置 visible 就会显示出来
  css 计数器，dis 不会被计数，vis 会
  dis 触发回流，vis 不触发回流

- 隐藏元素的方法
  - display=none
  - 脱离文档流，设置位置离开显示区域
  - visibility=hidden

- position 属性
  - static，正常文档流，默认值；
  - relative，相对布局，通过 top、bottom、left、right 可相对元素在文档流中的位置移动；不脱离文档流；
  - absolute，绝对布局，通过 top、bottom、left、right 可相对 position 属性不为 static 的父元素在文档流中的位置移动；脱离文档流；
  - fixed，绝对布局，通过 top、bottom、left、right 可相对浏览器窗口的位置移动；脱离文档流；

- BFC（什么是 BFC，BFC 的特性，BFC 的创建，BFC 的应用）
  - 什么是 BFC
    - 块级格式化上下文，一个 BFC 包含它的所有子元素但不包含创建了新 BFC 的子元素的子元素
  - BFC 的创建
    - html 标签
    - float!==none
    - position（fixed、absolute）
    - overflow!==visible
    - 行内块元素 display=inline-block
    - display 为 table 或 table-cell 或 table-caption 或 inline-table
  - BFC 的特性
    - 同一 BFC 下的块级元素垂直排列
    - 同一 BFC 下的相邻块级元素垂直外边距重叠
    - BFC 中高度计算包含浮动元素的高度
    - BFC 不会与浮动元素重叠
    - 一个 BFC 下的子元素左边 margin 和包含块左边 border 接触
  - BFC 的应用
    - 清除浮动；BFC 中高度计算包含浮动元素的高度
    - 避免垂直外边距重叠；创建新的 BFC 使子元素处于新 BFC 中就不会与之前 BFC 的元素重叠垂直外边距
    - 自适应多栏布局，左右浮动，中间创建 BFC 自适应；因为 BFC 不会与浮动元素重叠

- 元素的浮动（什么是浮动，浮动的作用，怎么触发，缺点，为什么清除浮动，几种清除浮动的方法）
  - 元素设置 float 属性为 left/right，元素脱离文档流，向左/右浮动，直到碰到父元素或其他浮动元素
  - 诞生为了实现文字环绕（图片设置浮动就会文字环绕），主要应用于自适应多栏布局
  - 若父元素无高度，会造成父元素高度塌陷
  - 清除浮动
    - 加一个空 div，css 属性设置为 clear: both，原理为创建新元素让他左右没有浮动元素，也就是处于浮动元素下方，父元素计算高度会算上这个元素，也就解决了高度塌陷的问题
    - 创建父元素 BFC，BFC 计算高度会把浮动元素包含在内

- 水平垂直居中方法
  - 水平
    - 行级元素：text-align=center
    - 块级元素：margin=0 auto
    - position=absolute transform=translate（-50%，0）
    - width=fit-content margin=0 auto
    - flex
  - 垂直
    - 行级元素：line-height 和父元素一样
    - position=absolute transform=translate（0，-50%）
  - 水平垂直
    - flex
    - 行级元素：line-height 和父元素一样，text-align=center
    - position=absolute transform=translate（-50%，-50%）

- CSS 宽度尺寸
  - fill-available：宽度充满父元素
  - min-content：宽度以子元素最小宽度最大的宽度为准
  - max-content：宽度以内容最大宽度为准，空间无限大
  - fit-content：子元素浮动元素，可配合 margin：0 auto 使子元素居中
- flex 0 1 auto 代表什么
  - flex-grow，当子元素小于父元素时如何分配空间，比如子元素都为 1，那就是等分空间
  - flex-shrink，当子元素大于父元素时如何缩小子元素，0 不缩小，1 等比缩小
  - flex-basis，设置元素在主轴上的占据的空间，auto 为按内容大小占用，设置为固定值就是占用大小等于固定值

### Vue

- MVC 和 MVVM 的区别
  MVC 框架 view 层和 model 层的变化操作都在 c 层，c 层繁重不易维护，需要开发人员频繁操纵 dom，容易造成性能问题；
  MVVM 则利用双向绑定，将 Model 层和 View 层通过 ViewModel 层双向绑定，并将响应模式封装到 VM 层，开发人员不用频繁操纵 dom，只需告诉 VM，
  View 和哪个 Model 有关联即可实现双向响应，大大提升了性能和开发效率；

- 响应式原理
  Vue 响应式利用了数据劫持和发布订阅模式实现；描述一下大体流程，首先当 Vue 实例创建时，会实例化一个观察者包含视图更新方法（同时将 Dep.target 全局变量指向自己），遍历 data 中数据，
  对每个对象的每个属性使用 Object.defineproperty 进行劫持，get 属性用于依赖收集，
  实例化订阅者（包含观察者数组用来存放观察者，以及通知方法触发观察者中的数据更新方法）将观察者存放到订阅者中，
  set 属性将调用订阅者中的通知方法，通知观察者视图更新；这样在数据更新时，视图即可更新；创建新的 virtualDom 树，diff 对比进行对应地方更新；

- 双向绑定原理
  - model-view；采用数据劫持结合发布-订阅模式,通过 Object.defineproperty 来劫持各个属性的 setter,getter,在数据变动时发布消息给订阅者,触发响应的监听回调；
  - view-model，v-model 语法糖；Vue 通过对 view 输入事件监听修改 model；

- 生命周期
  - beforeCreate
    此时获取不到 data、props 以及 methods，这些都在 init 阶段；
  - created
    能够获取到 data、props 和 methods 中的数据，但组件还没有挂载是看不到的；可用于调用接口；
  - beforeMount
    页面已经编译了但还没有渲染，已经生成了 VDOM
  - mounted
    页面渲染完成
  - beforeUpdate
    data 中数据改变，渲染页面之前
  - update
    data 中数据改变，页面渲染完成时调用

- 如何传值
  - 父子
    - 通过 props 传值，子组件通过\$emit 调用父组件方法传值
    - $parent、$children
    - v-model
    - .sync 修饰符
  - 兄弟
    - $parent.$children
  - 多层次
    - provide/reject,父级组件通过 provide 生命的属性子组件可通过 reject 访问
    ```
    // 父组件 A
    export default {
       provide: {
          data: 1
       }
    }
    // 子组件 B
    export default {
       inject: ['data'],
       mounted() {
          // 无论跨几层都能获得父组件的 data 属性
          console.log(this.data) // => 1
       }
    }
    ```
  - 任意组件
    - eventbus，注册一个自定义指令 EventBus，通过$emit和$on 发送和监听数据，在组件销毁时要调用\$off 销毁监听
    - vuex

- watch 和 computed 区别
  - computed 计算属性，是依赖于属性的，会有缓存，再依赖的属性值没有变化时调用会直接返回之前的结果，不会执行函数；经常与 VUEX 一起使用，将要获取的 store 中的数据放在 computed 中，值变化时会更新页面
  - watch，监听属性变化，有新旧两个值，可以在变化时添加业务逻辑；对象的深层次监听需要设置 deep
- v-show 和 v-if 区别
  - v-show 切换 display:none
  - v-if 直接创建或删除 dom，为 false 时不会渲染

- nextTick
  在 dom 重新渲染之后触发回调函数，vue 更新 dom 是异步操作，当实例 watcher 被触发时会创建一个队列，在下次事件循环中触发；若同一个 watcher 在一个事件循环中被触发多次，则只会被加入到队列中一次；所以在修改数据导致页面重新渲染时，页面不会立即渲染，若想在渲染后进行业务操作就需要用到 nextTick，它支持传入一个函数，这个函数会被存到队列中（使用 promise、setTimeout、setImmediate），在下一次事件循环中会执行所有的这些函数；
```
   this.$nextTick(function () {
        console.log(this.$el.textContent) // => '已更新'
   })
```

- history 和 hash
  前端路由的核心是改变视图的同时不会向后端发出请求，实现页面的无刷新跳转
  - hash 有个#，在请求服务器时不会带上#，丑一点，但是省事，不需要服务器配置。原理为路由对象将不同 hash 值的回调函数存储，监听 hashChange 事件调用不同 hash 值下的回调函数切换视图；
  - history 借助 html5 的 History API，通过 pushState 向浏览器添加历史记录，replaceState 修改历史记录，所以不会触发刷新；
    缺点在点击刷新时会给服务器发送请求，造成 404，需要配置 404 时指向根目录

- diff

- Virtual Dom

### 浏览器

- 进程和线程的区别
  - 进程是程序运行的实例，当运行一个程序时，操作系统会在内存中为其分配一块内存用来存放代码，运行中的数据和一个执行任务的主线程，这个运行环境就是进程；
  - 线程依附于进程，用于执行任务，一个线程只能属于一个进程，一个进程可以分配多个线程，多线程并行处理能够大大提升性能；
  - 两者关系特点
    - 线程之间共享进程的数据
    - 进程之间数据不共享，通信需要使用 IPC
    - 同一进程下的任意线程崩溃都会导致整个进程崩溃
    - 进程关闭时操作系统会回收这部分内存

- 浏览器架构
  - 多进程架构优点：提升了稳定性，安全性，流畅性；缺点：更高的资源占用，每个渲染进程中都有 V8 引擎；更复杂的体系结构，各个模块耦合性较高；
  - 浏览器主进程
    用户交互、子进程管理、存储等功能
  - 渲染进程
    用于将 CSS、HTML 转换为浏览器可识别的模样，排版引擎和 JS V8 引擎都在渲染进程中，每打开一个 Tab 页都会创建一个新的渲染进程，同一站点（根域名（例如，geekbang.org）加上协议（例如，https:// 或者http://）相同）除外，
  - 插件进程
    用于运行插件，由于插件易崩溃，防止影响主进程而增加的进程
  - 网络进程
    用于网络资源加载
  - GPU 进程
    用于绘制页面

- 浏览器渲染过程
  - 构建 DOM 树
    - 将 html 转化为浏览器能够识别的树形结构，可通过 JS 读写
  - 样式计算：为 DOM 树所有元素添加对应的 CSS 样式
    - 将 CSS 转化为能够识别的 styleSheet
    - 将属性值标准化，比如应用了 em，rem 等，red 等
    - 根据继承和层叠为每个 DOM 节点对应 CSS 样式，生成 computedStyle
  - 布局阶段：计算出 DOM 元素的几何位置
    - 额外创建一个只包含 DOM 中可见元素的布局树 LayoutTree
    - 布局计算，几何位置计算
  - 分层
    - 为了 3D 动画，层叠效果（z-index、透明度、position 属性、截取文本）等，对布局树进行分层生成 LayerTree
  - 图层绘制
    - 为图层生成绘制列表（把图层绘制分步形成列表），提交给合成线程
  - 栅格化
    - 合成线程将图层分为图块，先渲染视口附近，将视口附近的图块交给珊格线程池（加快首屏显示）
    - 珊格线程池将图块转为位图（点阵图像，由像素点组成），位图交给合成线程，都转化完合成线程会提交给浏览器进程
  - 合成与显示
    - 浏览器进程生成页面存于内存中发给显卡，显示

- 重绘和回流
  - 回流
    修改了 DOM 元素的几何属性，渲染流程都需重新运行一遍，开销较大
    - width、height、padding、margin、left、top、border 等几何属性
    - 使 DOM 元素移动或增减
    - 读写 offset 族、scroll 族和 client 族属性的时候，浏览器为了获取这些值，需要进行回流操作。
    - 调用 window.getComputedStyle 方法
  - 重绘
    修改的属性不会使 DOM 几何属性变化，渲染流程跳过布局和分层的阶段直接进入图层绘制阶段
    - color

- 浏览器事件循环

- 垃圾回收

- 从输入 URL 到显示界面都发生了什么
  - DNS 解析
  - TLS 握手
  - TCP/IP 握手
  - http 请求
  - 将获取的页面渲染

### Http/Https

- cookie
  - cookie 是存储在客户端的一小块数据，http 是无状态的，cookie 的作用就是维护状态，让服务器知道两次请求来自同一个客户端；cookie 是在第一次请求中由服务端放在响应头的 setCookie 字段中，浏览器收到会将其缓存，下次请求时会自动带着 cookie 表明身份；
  - cookie 的属性，以建值对的形式存储，name: value; domain: 域名，指定能够携带的目标域名; path: 路径，必须包含这个路径才能携带 cookie domin 和 path 共同指定了 cookie 的作用域; secure: true 只会在安全协议中; Expires/Max-age: 过期时间/存活秒数; httpOnly: 是否可用 JS 获取修改 cookie; SameSite：strict 只允许相同站点（跨站请求不允许携带 cookie），Lax 允许部分第三方（a，get 的 form 表单，link（iframe、ajax、img、post 表单都不允许）），None 无论是否跨站都发送
  - cookie 缺陷
    - 容量：大小只有 4KB
    - 性能：若不设置路径的情况下，访问相同域名都会带上 cookie，造成不必要的资源浪费
    - 安全：以纯文本形式传输，容易被截取恶意携带 cookie 向服务器发送请求 XSS 攻击；可被 JS 读写

- 跨域
  - 由于浏览器的同源策略（协议主机和端口均相同），向不同源的服务器发送请求会造成跨域，该请求发出后，服务器会作出响应，但如果响应头中没有 CORS 字段，浏览器会把响应废弃；
  - 解决办法
    - JSONP
      - 虽然 XMLHttpRequest 对象遵循同源政策，但是 script 标签不一样，它可以通过 src 填上目标地址从而发出 GET 请求，实现跨域请求并拿到响应。
        将 get 和回调函数拼接放入 src 属性中发出 get 请求，服务端将返回数据放入回调函数入参中即可，客户端收到响应指向回调函数拿到数据；
    - CORS（跨域资源共享）
      - 浏览器发出请求时会添加 Origin 字段，服务器拿到请求之后，在回应时对应地添加 Access-Control-Allow-Origin 字段，
        如果 Origin 不在这个字段的范围中，那么浏览器就会将响应拦截。
    - Nginx 反向代理
      - 比如客户端为 client.com，服务器为 server.com，客户端向服务器请求访问 server.com/api，Nginx 相当于起了一个跳板机，
        这个跳板机的域名也是 client.com，让客户端首先访问 client.com/api，这当然没有跨域，然后 Nginx 服务器作为反向代理，
        将请求转发给 server.com，当响应返回时又将响应给到客户端，这就完成整个跨域请求的过程。

- 常见状态码
  - 1xx: 接受，继续处理
  - 200: 成功，并返回数据
  - 201: 已创建
  - 202: 已接受
  - 203: 成功，但未授权
  - 204: 成功，无内容
  - 205: 成功，重置内容
  - 206: 成功，部分内容
  - 301: 永久移动，重定向
  - 302: 临时移动，可使用原有 URI
  - 304: 资源未修改，可使用缓存
  - 305: 需代理访问
  - 400: 请求语法错误
  - 401: 要求身份认证
  - 403: 拒绝请求
  - 404: 资源不存在
  - 500: 服务器错误

- get/post 区别
  - get 请求在 url 中，post 在请求体中，导致 get 请求不安全
  - get 请求有缓存，post 请求没有
  - 浏览器后退时 get 请求不会重新发送，post 会
  - get 请求受 url 长度限制，post 不会

- TLS 握手（http 和 tcp 的中间层 TLS 协议）
  - 客户端生成随机数 client_random 以及加密套件发送给服务端
  - 服务端返回确定的加密算法以及证书和随机数 server_random
  - 客户端解析证书确认身份同时获取公钥，生成随机数 pre_random，将随机数用公钥加密，用三个随机数得出密钥
  - 服务端用私钥解密得到 pre_random，同时用三个随机数生成密钥

- http 缓存（分为浏览器直接判断的强缓存和发送 http 请求让服务端判断的协商缓存）
  - 强缓存
    - 首先是检查强缓存，这个过程不需要发送 http 请求。http/1.0 当中靠 Expires 来检查，Expires 存在于服务端响应头中，标明了缓存的过期时间。
      当浏览器要继续发送该请求时会对比当前时间和过期时间，没过期命中，过期了发送 http 请求进入协商缓存阶段（缺陷，服务端和客户端时间有可能不同）。
      http/1.1 当中使用 Cache-control 来判断，也存在于响应头当中，使用 max-age 字段标明了缓存的存活时间，秒为单位，表示未来的多长时间可以使用缓存。
      过期进入协商缓存。
  - 协商缓存
    - 强缓存失效后，浏览器发送 http 请求时会携带相应的缓存标签用来给服务端判断是否命中协商缓存。缓存标签分为两种。
      - Last-Modified：
        即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。
        浏览器接收到后，如果再次请求，会在请求头中携带 If-Modified-Since 字段，这个字段的值也就是服务器传来的最后修改时间。
        服务器拿到请求头中的 If-Modified-Since 的字段后，其实会和这个服务器中该资源的最后修改时间对比:如果请求头中的这个值小于最后修改时间，
        说明是时候更新了。返回新的资源，跟常规的 HTTP 请求响应的流程一样。否则返回 304，告诉浏览器直接用缓存。
      - ETag：
        服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。
        服务器通过响应头把这个值给浏览器。浏览器接收到 ETag 的值，会在下次请求时，将这个值作为 If-None-Match 这个字段的内容，并放到请求头中，
        然后发给服务器。服务器接收到 If-None-Match 后，会跟服务器上该资源的 ETag 进行比对:如果两者不一样，说明要更新了。
        返回新的资源，跟常规的 HTTP 请求响应的流程一样。否则返回 304，告诉浏览器直接用缓存。
        
- http2 有何改进
- 网络模型

### Tcp/Ip

- UDP 和 TCP 区别
  UDP 是面向无连接的传输层协议，有不可靠性；不会对数据进行备份和排序，不管数据是否有序到达接收方，也没有流量控制和拥塞处理算法，导致在网络环境不好的情况下容易丢包；但是这也体现了 UDP 轻便的特点，在需要实时传输的场景有很好的应用，比如网络直播网络游戏等；
  TCP 是面向连接的传输层协议，通过超时重传协议保证了数据的完整性；流量控制和拥塞处理算法解决了网络拥塞问题，能保证在不同网络环境下稳定传输；但保证稳定的同时也就丢失了一些实时性；

- TCP 怎么保证数据完整到达接收方
  通过超时重传协议（ARQ）；
  - 停止等待 ARQ：当发送方发出报文时会打开一个定时器，在定时器结束之前收到接收方应答就是正常；如果未收到就会重传之前的报文；如果确认报文丢失，发送方会继续发送，接收方会丢弃这段报文等待新报文的接收；（定时器的设置会大于一个 RTT 从发出报文到接收到对端确认报文的时间）
  - 连续 ARQ：发送方会维持一个发送窗口，在窗口范围内连续分组发送数据，接收方不会连续确认，而是过一段时间后，将接收到的数据中按序到达的最后一个分组确认，发送方每收到一次确认就往前滑动一个分组；

- 三次握手（为什么三次握手，什么是半连接队列，握手过程可以传输数据吗，什么是 SYN 攻击）
  - 三次握手过程
    - 双方都是 Close 状态，客户端发送 SYN 包请求连接（包含 SYN=1，初始序列号 seq=x，确认为 ACK 为 0）进入 SYN_send 状态
    - 服务端收到连接请求，将连接放入半连接队列中，回复 SYN+ACK 确认包（SYN=1，确认位 ACK=1，初始序列号 seq=y，确认序列号 ack=x+1）进入 SYN_Received 状态
    - 客户端收到确认，回复 ACK 确认包（ACK=1，ack=y+1，seq=x+1（第一次消耗一个序列号）），进入 established 状态，服务端收到客户端确认包后也会进入 ESTABLISHED 状态，并把连接放入全连接队列。
  - 为什么三次握手
    确认双方收发能力正常，同时为了避免因网络状况造成的服务端资源浪费问题，场景为客户端超时请求连接报文被服务端接收，服务器再次进入 ESTABLISHED 状态，而此时客户端已经 CLOSE，服务端一直等待客户端数据，造成资源浪费
  - 什么是半连接队列
    存放客户端 IP 地址，第一次握成功的客户端 IP 地址
  - SYN 攻击
    使用伪造 IP 地址一直给服务端发送连接请求导致服务端半连接队列爆满，造成服务端一直给假 IP 发送确认包，造成资源浪费，也使真正的请求无法被接收；解决方法可以增大半连接队列，减少重传次数；

- 四次挥手（为什么四次握手）
  - 四次挥手过程
    - 客户端向服务端发送 FIN 断开请求（FIN=1，ACK=0，seq=x）进入 FIN_WAIT1 状态
    - 服务端接收到，发送确认断开包（ACK=1，ack=x+1），进入 CLOSE_WAIT 状态；表明此时 a 到 b 的连接已断开，不会再接受 a 的数据，但此时服务端可能仍有数据要发送
    - 服务端数据发送完毕也要断开连接了，给客户端发送断开请求包（FIN=1，ACK=0，seq=y）进入 LAST_ASK 状态
    - 客户端收到，发送确认包（ACK=1，ack=y+1），进入 FIN_WAIT2 状态，等到 2MSL（报文最大存活时间，确保服务端收到自己的确认，如果未收到就断开连接，服务端会一直等待客户端的确认，导致服务端不能正常关闭）后进入 CLOSE 状态，服务端收到后进入 CLOSE 状态；
  - 为什么四次挥手
    服务端可能未发送完数据，等等发送完才能断开连接

- 流量控制和拥塞处理
  - 流量控制 - 滑动窗口（解决丢包，数据不对以及流量控制的问题）
    TCP 中发送端和接收端各维护着一个窗口，发送窗口和接收窗口，发送窗口包含已发送但未得到确认的数据和可以发送但未发送的数据；发送窗口的大小
    是由接收方接收窗口的剩余大小决定的；接收方会把窗口剩余大小放入应答包中发送给发送方，发送方根据大小以及网络情况确定发送窗口的大小；这样确保了接收方能够接收到数据，避免了接收方带宽已满但发送方仍在发送的问题；接收方为 0 窗口时，发送方会设定定时器，定时询问接收方窗口大小，若超过一定次数会中断 TCP 连接；
    拥塞处理（防止过多数据拥塞网络，保证长时间稳定的在不同网络环境中较好的传输数据）
  - 拥塞处理（解决网络问题）
    - 慢启动
      1.  将发送窗口设为 1MSS（1 分段最大数据量）
      2.  每过一个 RTT 将窗口大小乘 2
      3.  有一个阀值限制，超过阀值启动拥塞避免算法
    - 拥塞避免：每过一个 RTT 把窗口大小+1，当定时器时间到了没收到确认包时统一认定是网络拥塞问题，进行如下处理
      1.  将阀值设置为当时窗口的一半
      2.  发送窗口设置为 1MSS
      3.  启动拥塞避免算法
    - 快速重传
      - 当报文失序时，接收方会发送最后一个有序的序号作为应答，当发送端收到三个相同的 ACK 时，不等待定时器结束，开始快速重传算法；
      - TCP Reno
        1. 发送窗口减半
        2. 阀值设置为当前拥塞窗口
        3. 进入快恢复阶段（重发对端需要的包，一旦收到一个新的 ACK 答复就退出该阶段），这种方式在丢失多个包的情况下就不那么好了
        4. 启动拥塞避免算法
      - TCP New Ren 改进后的快恢复
        TCP New Reno 算法改进了之前 TCP Reno 算法的缺陷。在之前，快恢复中只要收到一个新的 ACK 包，就会退出快恢复。
        在 TCP New Reno 中，TCP 发送方先记下三个重复 ACK 的分段的最大序号。
        假如我有一个分段数据是 1 ~ 10 这十个序号的报文，其中丢失了序号为 3 和 7 的报文，那么该分段的最大序号就是 10。
        发送端只会收到 ACK 序号为 3 的应答。这时候重发序号为 3 的报文，接收方顺利接收的话就会发送 ACK 序号为 7 的应答。
        这时候 TCP 知道对端是有多个包未收到，会继续发送序号为 7 的报文，接收方顺利接收并会发送 ACK 序号为 11 的应答，
        这时发送端认为这个分段接收端已经顺利接收，接下来会退出快恢复阶段。

### 第一轮面试问题总结

- SEO
  - SEO 是搜索引擎优化，目的是使网站在搜索引擎中排名上升，提高权重，同时也优化了用户体验，增加用户量；
  - 实现方向
    1.  优化网站结构
        - 控制首页链接：要有各个功能的内部链接便于爬虫跳转，但无用链接要减少，会降低用户体验；
        - 目录扁平化：尽量层次不要超过 3 级，用户一般跳转三次没有得到想要的结果就会离开网站；
        - 利用布局主要内容放在前面：例如三栏布局，将中间栏写在 html 的最上面，左右两栏利用浮动，写在下面；
        - 增加导航：导航尽量使用文字，若用图片导航应添加 alt（网络不好的情况下图片展示的文字）和 title 标签描述图片；尽量在每个页面
          增加面包屑导航，不仅可以让爬虫方便明确结构，大量的内部链接使其方便抓取，降低跳出率。也可使用户体验提升，了解网站结构，提供的跳转接口也便于操作；
        - 控制大小：过大容易造成加载时间过长，导致爬虫放弃爬取，用户体验也较差；
    2.  优化代码
        - 合理设计 description、keyword、title 属性；关键词要准确但不能胡乱堆砌；
        - 标签语义化，使用对应标签描述对应内容，合理使用 h1-h6，nav 等标签，让阅读者和爬虫一目了然；
        - <a>标签对于内部链接要增加 title 描述，外部链接要增加 rel=nofollow,因为爬出去就不会回来了；
        - <img>标签要添加 alt 和 title 描述；
        - 使用强调标签，<strong><em>它们有强调作用，将关键字放入会引起搜索引擎的高度注意，<b><i>只是显示效果，对 seo 没有作用；
        - 重要代码不要放在 js 中，爬虫不理解 js，要放在 html 中；
        - display: none 要谨慎使用，其中的内容会被爬虫舍弃；
    3.  提升网站性能
        - 使用 CDN 缓存
          - 使用 CDN 可以减轻服务器压力，加快请求速度；
        - GZIP 压缩
          - 可显著提升请求效率，需服务器配置；
        - 雪碧图
          - 用一张大图包含所有小图，减少 http 请求次数，利用 css 的 background-position 属性使用雪碧图
        - 使用字体图标
        - 懒加载
          - 只加载视口部分的列表，待用户滚动到视口三分之二再加载下一部分列表；
        - 减少回流
          回流会触发整个渲染流程，开销较大；可通过以下方式避免；
          - 减少修改元素几何属性，height、width、left、margin、padding 等
          - 减少对 dom 元素的移动和增减
          - 减少对 scroll 属性的获取
          - 避免获取 computedStyle
        - 减少 dom 操作
          - dom 操作比较耗费性能，减少 dom 操作可以有效提高性能；
        - 利用浏览器缓存
          - 不经常变化的文件可利用浏览器缓存，减少请求次数，优化加载速度；
    4.  总结
        了解 SEO，但不过分 SEO，还是以网站内容为主；另外现在主流的都是单页面应用，对 SEO 没有作用，需要使用 SSR（服务端渲染）
- 前端模块化

- 服务端渲染

- webpack 配置
  一般配置两个文件，一个是生产环境，一个是开发环境；在开发环境中配置热更新，解析 css、sass、图片等；在生产环境配置文件指纹以及代码压缩和文件解析；在 package.json 中 script 属性中配置，dev 对应开发打包，build 对应生产打包
  - 热更新
    使用 webpack-dev-server 以及 webpack 自带的热更新插件，初次运行它会起一个本地 node 服务，在浏览器中与服务建立联系，当触发热更新打包时会将新文件发送给浏览器，进行页面更新；
  - 文件指纹
    - hash
      作用于项目，每次项目更新都会更新 hash，一般图片用这种方式
    - chunkhash
      作用于 chunk，每个 entry 是一个 chunk，这个模块更新了就会更新 chunkhash，一般用于 js 文件
    - contenthash
      作用于内容，内容改变时会触发 contenthash，一般 css 文件使用，借助于 MiniCssExtractPlugin 插件，注意的地方在于与 style-loader 冲突，style 会将打包好的 css 直接放入 html 的 head 标签中，不会创建 css 文件，而 MiniCssExtractPlugin 会创建 css 文件，进行打包

### 面试腾讯之前的总结

## 浏览器兼容性

- 布局问题
  - 不同浏览器 padding 和 margin 默认值不同；解决办法：通配符选择器\*{padding:0;margin:0;}；
  - 块元素设置浮动和横向 margin，在 IE6 中会显示的比设置的大；解决办法：元素设置 block:inline；
  - 给元素设置较小的标签（10px 以下），IE6，IE7 会超出自己设置的高度；解决办法：给超出元素设置 overflow:hidden，或者设置小的行高；
  - 图片默认有间距，img 是行级标签，在横向排列时有些浏览器会出现间距；解决办法：使用 float；
  - chrome 下默认会将小于 12px 的文本解析为 12px；解决办法：-webkit-text-size-adjust:none；
  - 透明度 opacity:0.6；IE filter:alpha(opacity=60)
- js
  - vue 不支持 IE8 以下浏览器
  - event 事件问题，获取 event 对象，谷歌和火狐从方法形参获取，低版本 IE 在 window 对象下获取
  - 阻止冒泡，event.stopPropagation，IE 是 event.cancelBubble

## 前端安全防范

- XSS 攻击，指在浏览器中执行恶意脚本从而拿到用户信息进行操作
  - 恶意脚本做的事情
    - 窃取 cookie
    - 监听用户行为，比如输入账号密码后发送到黑客服务器
    - 修改 DOM 伪造登录表单
    - 在页面展示浮窗广告
  - 类型
    - 存储型，从用户输入部分输入恶意脚本，若前后端没有进行转义直接存储进数据库，每次打开客户端都会执行这个脚本
    - 反射型，将恶意脚本作为网络请求的一部分，脚本作为参数拼接在请求中，服务器将内容反给浏览器，浏览器当作 html 的一部分进行执行
    - 文档型，作为中间人的角色，在数据传输过程中劫持到网络数据包，然后修改里面的 html 文档
  - 解决办法
    - 设置 cookie 的 httpOnly 属性，使 js 访问不到 cookie
    - 不信任用户的输入，对用户输入进行转码或过滤
- CSRF 攻击，跨站请求伪造，诱导用户点击，利用用户的登录状态发起跨站请求
  - 方式
    - 自动发送 get 请求，诱导点击图片，图片自动发送 get 请求，（如果用户已经在目标网站登录过）请求会自动带上目标网站的 cookie 信息，服务端若没有相应的验证方式可能会认为发请求的是正常用户，就可以进行各种恶意操作
    - 自动发送 post 请求，黑客自己填写了一个表单，写了一段自动提交的脚本，也会携带着用户的 cookie 信息，让服务器误以为是用户正常操作
    - 诱导发送 get 请求，黑客在网站放上一个链接，诱导点击
  - 解决办法
    - 利用 cookie 的 sameSite 属性
    - 验证来源站点，服务器验证请求的 Origin

### 腾讯一面

## 笔试题

- Math 的 api
- 排序

## 项目

- RN 遇到的问题

## http

- 是否还在使用 SSL
- http 的缺陷
- TLS 握手
- tcp 三次握手

## Vue

- cookie
- 性能优化，从浏览器渲染流程看
  - dns 查询
  - http 请求
    - 减少重定向，重定向比较影响用户体验，只能看到浏览器地址栏在更新
    - 减少次数
      - 雪碧图，使用 background-position
      - 利用 http 缓存
      - 利用本地缓存 local 和 sessionStorage
      - 合理使用 keep-alive 建立长连接
    - 优化文件大小
      - 压缩 js、css 文件
      - 服务端 gzip 压缩
    - 使用 cdn 减轻服务器压力
      - 图片借助 cdn 优化下载速度
    - 并行加载，把文件放在不同的域名
  - cookie 注意
    - 使用 domain 和 path 属性限制 cookie 作用域，不要每次请求都带着 cookie
    - 尽量压缩 cookie 大小
    - 设置合适的过期时间
  - 渲染过程
    - css
      - 样式表放在<HEAD>标签中能使页面逐渐渲染
      - 使用 link 引入，link 一边导入 css 一边加载，@import 是同步操作
    - js
      - 减少 dom 操作（减少重绘回流）
        - 减少 dom 元素的动态增加和删除
        - 避免修改 dom 元素 css 影响布局属性比如 height、width、positon、margin 等
        - 避免获取 computedStyle
        - 避免对 scroll 属性的获取
      - 减少绑定数据监听事件，可以使用事件委托通过事件冒泡机制获取触发的子节点事件
      - 避免递归死循环爆栈
      - 减少闭包引发的内存泄漏
      - 防抖和节流
        - 防抖，每当有一个新事件触发就开启一个定时器并清除上一个定时器，设定的时间内没有新事件触发才会执行回调函数
        - 节流，一段时间内只触发第一次的回调函数
    - 懒加载
      - 图片（页面渲染完成之前先展示一个占位图，之后再发送请求填充占位图）、列表懒加载

- 前端工程化
- rn 优化性能
