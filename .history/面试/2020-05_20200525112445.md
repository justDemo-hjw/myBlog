<!--
 * @Date: 2020-05-20 20:31:15
 * @LastEditors: hanjiawang
 * @LastEditTime: 2020-05-25 11:24:45
--> 

# 一轮复习

## 自我介绍
面试官你好，我叫韩嘉旺，21岁，是今年6月份毕业的本科生，我在途牛公司有一年前端工作经验；就职期间我参与研发了两个项目；一个是途牛商旅app使用的是React-Native技术栈；完成了整体百分之20的任务量；另一个是使用基于vue的uni-app框架研发了途牛商旅的h5端、微信小程序端和企业微信端；完成了百分之30的任务量；

## 项目介绍以及准备的点
1. 途牛商旅h5端、小程序端、企业微信端：途牛商旅是途牛公司toB业务的主要产品，目的是为了让员工出差更方便，途牛商旅内含审批单系统，
有事前审批 和事中审批两部分，在员工出差时可根据审批单等各种配置来限制审批和出差预算，出行地点等，在支付时可以不用员工 垫付而是由途牛垫付，
最后一起报销，可以让员工出差更方便，企业在管理上也更加方便。我主要负责了机票酒店火车票的三条业务线开发，机票退票业务，滴滴页面的嵌入等难点如下；
   - 封装了适配多业务线的日历控件
      - 分析业务需求确定组件入参
         1. 模式（机票往返、机票多程、机票单程、火车、酒店）
         2. 上次选择的开始日期结束日期
         3. 要展示的月份个数 
      - 封装组件
         - 计算日期数据
            - 根据入参中的月份个数使用for循环遍历，i从0到这个月份，遍历这么多次；先创建月份对象，包含当前月份日期数组、月份、年份；
            创建总的日期渲染数据源数组，存放所有的月份对象；
            先确定当前月份和年份存入月份对象中，再确认这个月有多少天，判断1号是星期几，把前面空着的用null代替，将数据存入月份对象中的日期数组；
            每个月遍历后，总数据源就确定了； 
         - 渲染数据
            - 头部，星期标尺，遍历总日历数据，每月的头部加上年份和月份；
            - 遍历每个月份数据中的日期数据，从头开始排即可
            - 绑定点击事件（获取到具体日期，选完展示确定按钮）
         - 适配不同业务模式ui
            - 为不同模式适配不同的头部，点击限制逻辑，每个日期部分的展示内容等
         - VueX做状态管理
            - 点击确定将数据存入Store中便于业务线获取时间
   - h5端转小程序端的一些坑
      - 分包
         - 要求主包分包总大小不能超过12m，分包大小不能超过2m
            - 借助CDN
         - 在page.json中配置
      - v-show不支持
      - 样式不能用方法返回
      - v-html不支持
      - 分包之间不能引用，主包也不能引用分包
      - 不能使用浏览器自带对象如document、window等
      - 选择器支持问题
         - id选择器，last-child
      - 不能很好的定位bug，有时页面白屏，没有提示
   - 手机端自适应
      - rpx 微信小程序规定iphone6宽度为750rpx，此时1px=2rpx，设计稿以iphone6为基准进行设计，开发中各种机型自然自适应
   - 性能
      - 使用代码压缩
         - webpack配置方法
      - 借助CDN减少服务器压力
      - 懒加载
      - 去除冗余代码
2. 途牛商旅app，业务相同；我主要负责了机票酒店火车票的三条业务线开发
   - 适配机型
      - 设计稿Iphone6，适配IphoneX留海屏statusBar高度，iphonex44，往上抬25
   - 性能处理（shouldComponentUpdate）
## 面试知识点总结

### CSS
- CSS的引用
link标签和@import
   - 从属关系，link不仅可以加载css还可以设置RSS，rel连接属性等，而@import只能用来导入css样式
   - 加载顺序，link随dom加载，@import则在页面加载完成之后加载
   - dom操作，link导入的样式可通过js修改，@import不可
   - 兼容性，@import IE5之上可用，link则都支持

- CSS的优先级
!important>行内样式>id选择器>类选择器>标签选择器>通配符选择器>继承属性>默认

- 盒模型
   - content-box:宽高包含内容部分大小
   - border-box:宽高包括内容部分内边距和内边框的大小
   - padding-box:宽高包含内容部分和内边距大小
   - margin-box:宽高包含内容内边距内边框和外边距

- display=none和visibility=hidden的区别
display不占用文档流，visibility占用文档流
继承，父类display=none子类必被隐藏，而父类visibility设置hidden，子类设置visible就会显示出来
css计数器，dis不会被计数，vis会
dis触发回流，vis不触发回流

- 隐藏元素的方法
   - display=none
   - 脱离文档流，设置位置离开显示区域
   - visibility=hidden

- position属性
   - static，正常文档流，默认值；
   - relative，相对布局，通过top、bottom、left、right可相对元素在文档流中的位置移动；不脱离文档流；
   - position，绝对布局，通过top、bottom、left、right可相对position属性不为static的父元素在文档流中的位置移动；脱离文档流；
   - fixed，绝对布局，通过top、bottom、left、right可相对浏览器窗口的位置移动；脱离文档流；

- BFC（什么是BFC，BFC的特性，BFC的创建，BFC的应用）
   - 什么是BFC
      - 块级格式化上下文，一个BFC包含它的所有子元素但不包含创建了新BFC的子元素的子元素
   - BFC的创建
      - html标签
      - float!==none
      - position（fixed、absolute）
      - overflow!==visible
      - 行内块元素 display=inline-block
      - display为table或table-cell或table-caption或inline-table
   - BFC的特性
      - 同一BFC下的块级元素垂直排列
      - 同一BFC下的相邻块级元素垂直外边距重叠
      - BFC中高度计算包含浮动元素的高度
      - BFC不会与浮动元素重叠
      - 一个BFC下的子元素左边margin和包含块左边border接触
   - BFC的应用
      - 清除浮动；BFC中高度计算包含浮动元素的高度
      - 避免垂直外边距重叠；创建新的BFC使子元素处于新BFC中就不会与之前BFC的元素重叠垂直外边距
      - 自适应多栏布局，左右浮动，中间创建BFC自适应；因为BFC不会与浮动元素重叠

- 元素的浮动（什么是浮动，浮动的作用，怎么触发，缺点，为什么清除浮动，几种清除浮动的方法）
   - 元素设置float属性为left/right，元素脱离文档流，向左/右浮动，直到碰到父元素或其他浮动元素
   - 诞生为了实现文字环绕（图片设置浮动就会文字环绕），主要应用于自适应多栏布局
   - 若父元素无高度，会造成父元素高度塌陷
   - 清除浮动
      - 加一个空div，css属性设置为clear: both，原理为创建新元素让他左右没有浮动元素，也就是处于浮动元素下方，父元素计算高度会算上这个元素，也就解决了高度塌陷的问题
      - 创建父元素BFC，BFC计算高度会把浮动元素包含在内

- 水平垂直居中方法
   - 水平
      - 行级元素：text-align=center
      - 块级元素：margin=0 auto
      - position=absolute transform=translate（-50%，0）
      - width=fit-content margin=0 auto
      - flex
   - 垂直
      - 行级元素：line-height和父元素一样
      - position=absolute transform=translate（0，-50%）
   - 水平垂直
      - flex
      - 行级元素：line-height和父元素一样，text-align=center
      - position=absolute transform=translate（-50%，-50%）

- CSS宽度尺寸
   - fill-available：宽度充满父元素
   - min-content：宽度以子元素最小宽度最大的宽度为准
   - max-content：宽度以内容最大宽度为准，空间无限大
   - fit-content：子元素浮动元素，可配合 margin：0 auto使子元素居中

### JavaScript
- 几种基本类型
   - null
   - undefined
   - number
   - string
   - boolean
   - symbol

- new 操作符
   1. 创建一个空对象obj
   2. 设置obj原型链，指向构造函数的原型
   3. 调用构造函数方法，this指向obj（继承方法和属性）
   4. 判断构造函数方法的返回值是不是引用值，是则返回这个引用值，不然返回obj
   - 
    ```
        function newFn(fn, ...args){
            let obj = {}
            Object.setPrototypeOf(obj,fn.prototype)
            let result = fn().apply(obj, args)
            return result instanceof Object ? result : obj
        }
    ```

- 原型/构造函数/实例
   - 原型是一个对象，有constructor属性指向构造函数
   - 构造函数有prototype属性指向原型对象，可用new操作符生成原型对象的实例
   - 实例是使用new操作符调用构造函数返回的对象，拥有__proto__属性指向原型对象

- 原型链：js调用对象属性和方法是一个查找过程，先从自身属性方法中查找，没有就去原型对象中查找，再没有就去原型对象的原型对象查找，直到找到Object的原型对象；这个过程就是原型链

- 类型判断
typeof判断基本类型，除null外都可（），判断引用类型时除了function都返回Object不准确若判断引用类型需要使用instanceof

- 类型转换
   - ToPrimitive(obj,type)将对象转为原始值，转为String类型则先调用toString在调用valueOf，转为Number类型则相反
   - 在使用运算符时会发生隐式转换
      - *，/，-，%都是转化为数值再比较
      - +规则
         - 数字 + 字符串 = 字符串
         - 前面加+会转化为Number类型
         - 数字 + 布尔值/null = 数字
         - 数字 + 对象， 优先调用ValueOf之后调用toString
         - 数字 + undefined = NaN
         
- 执行上下文
   - 可以理解为一个对象，包含三部分
      - 变量对象
      - this指向
      - 作用域链
   - 类型
      - 全局执行上下文
      - 函数执行上下文
      - eval执行上下文
   - 执行过程
      - 创建全局上下文
      - 全局上下文自上而下执行，遇到函数调用时将函数执行上下文放入栈顶
      - 执行函数上下文，执行完函数上下文出栈
      - 继续执行全局上下文

- 事件循环
   JS整个脚本会作为一个宏任务执行，执行过程中遇到setTimeout会将其中函数放入宏任务队列，
   promise.then会放入微任务队列中；执行完本次宏任务会清空微任务队列，之后再执行下一个宏任务；
   - 宏任务创建
      - script标签
      - setTimeout
      - setInterval
      - setImmediate
   - 微任务创建
      - promise
      - MutationObserver（监听dom树发生变化）
   
- 事件冒泡/捕获
    - 事件委托是利用事件冒泡的特性。将底层元素的响应事件委托到上层元素，因为事件冒泡特性是目标元素触发响应事件后会逐层触发上层的响应事件直到document；如果一个div下面有100个按钮，如果都绑定点击事件内存消耗会比较大，可以把点击事件绑定在父级div上；事件冒泡和事件捕获通过addEventListener的第三个参数控制，true是捕获，false是冒泡，默认是false；

- 浅/深拷贝

- == 和 === 的区别
   - === 先判断类型再判断值是否相等
   - == 在判断时若类型相同会进行判断值，若类型不同会进行类型转换在进行判断；类型转换的规则如下
      - 首先判断是不是在比较null和undefined，是的话返回true
      - 判断是不是String和Number，将String转为Number
      - 判读是否有一方为Boolean，将Boolean转为Number再判断
      - 判断是否有一方为对象，且另一方是Symbol、Number、String；将对象转为String类型判断“[object Object]”

- this
   - 直接调用指向window
   - 上下文对象调用指向对象
   - call、bind、apply改变指向
   - new操作符调用，指向创建的实例
   - 箭头函数没有this，和父级作用域的this指向一样

- 闭包
   - 能够访问其他作用域变量的函数；闭包的作用域包含了自己的作用域和包含它的函数作用域和全局作用域；其中访问的父级作用域的变量不会被垃圾回收（在javascript中，如果一个对象不再被引用，那么这个对象就会被垃圾回收机制回收；如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。），所以滥用闭包会导致内存泄漏
   - 通常以返回函数的方式出现；

- 继承
   - 寄生组合继承
   ```
     function father(){
        this.name = 'fa'
     }
     father.hha = function(){
        console.log('fa')
     }
     function son(){
        father.bind(this)
        this.sonName = 'son'
     }
     son.prototype = Object.create(father.prototype)
     son.prototype.constructor = son
   ```

- 作用域
   - 该上下文声明的变量以及它的应用范围，包含函数作用域和块级作用域

- 作用域链
   - 当获取一个对象时先从当前作用域查找，找不到会去父级作用域查找，直到全局作用域

### Vue
- MVC和MVVM的区别
MVC框架view层和model层的变化操作都在c层，c层繁重不易维护，需要开发人员频繁操纵dom，容易造成性能问题；
MVVM则利用双向绑定，将Model层和View层通过ViewModel层双向绑定，并将响应模式封装到VM层，开发人员不用频繁操纵dom，只需告诉VM，
View和哪个Model有关联即可实现双向响应，大大提升了性能和开发效率；

- 响应式原理
Vue响应式利用了数据劫持和发布订阅模式实现；描述一下大体流程，首先当Vue实例创建时，会实例化一个观察者包含视图更新方法，遍历data中数据，
对每个对象的每个属性使用Object.defineproperty进行劫持，get属性用于依赖收集，
实例化订阅者（包含观察者数组用来存放观察者，以及通知方法触发观察者中的数据更新方法）将观察者存放到订阅者中，
set属性将调用订阅者中的通知方法，通知观察者视图更新；这样在数据更新时，视图即可更新；创建新的virtualDom树，diff对比进行对应地方更新；

- 双向绑定原理
   - model-view；采用数据劫持结合发布-订阅模式,通过 Object.defineproperty 来劫持各个属性的 setter,getter,在数据变动时发布消息给订阅者,触发响应的监听回调；
   - view-model，v-model语法糖；Vue通过对view输入事件监听修改model；

- 生命周期
   - beforeCreate
   此时获取不到data、props以及methods，这些都在init阶段；
   - created
   能够获取到data、props和methods中的数据，但组件还没有挂载是看不到的；可用于调用接口；
   - beforeMount
   页面已经编译了但还没有渲染，已经生成了VDOM
   - mounted
   页面渲染完成
   - beforeUpdate
   data中数据改变，渲染页面之前
   - update
   data中数据改变，页面渲染完成时调用

- 如何传值
   - 父子
      - 通过props传值，子组件通过$emit调用父组件方法传值
      - $parent、$children
      - v-model
      - .sync修饰符
   - 兄弟
      - $parent.$children
   - 多层次
      - provide/reject,父级组件通过provide生命的属性子组件可通过reject访问
      ```
      // 父组件 A
      export default {
         provide: {
            data: 1
         }
      }
      // 子组件 B
      export default {
         inject: ['data'],
         mounted() {
            // 无论跨几层都能获得父组件的 data 属性
            console.log(this.data) // => 1
         }
      }
      ```
   - 任意组件
      - vuex
      
- watch和computed区别
   - computed计算属性，是依赖于属性的，会有缓存，再依赖的属性值没有变化时调用会直接返回之前的结果，不会执行函数；经常与VUEX一起使用，将要获取的store中的数据放在computed中，值变化时会更新页面
   - watch，监听属性变化，有新旧两个值，可以在变化时添加业务逻辑；对象的深层次监听需要设置deep

- v-show和v-if区别
   - v-show 切换display:none
   - v-if 直接创建或删除dom，为false时不会渲染

- nextTick
在dom重新渲染之后触发回调函数，vue更新dom是异步操作，当实例watcher被触发时会创建一个队列，在下次事件循环中触发；若同一个watcher在一个事件循环中被触发多次，则只会被加入到队列中一次；所以在修改数据导致页面重新渲染时，页面不会立即渲染，若想在渲染后进行业务操作就需要用到nextTick，它支持传入一个函数，这个函数会被存到队列中（使用promise、setTimeout、setImmediate），在下一次事件循环中会执行所有的这些函数；
```
   this.$nextTick(function () {
        console.log(this.$el.textContent) // => '已更新'
   })
```

- diff

- Virtual Dom

### 浏览器
- 进程和线程的区别
   - 进程是程序运行的实例，当运行一个程序时，操作系统会在内存中为其分配一块内存用来存放代码，运行中的数据和一个执行任务的主线程，这个运行环境就是进程；
   - 线程依附于进程，用于执行任务，一个线程只能属于一个进程，一个进程可以分配多个线程，多线程并行处理能够大大提升性能；
   - 两者关系特点
      - 线程之间共享进程的数据
      - 进程之间数据不共享，通信需要使用IPC
      - 同一进程下的任意线程崩溃都会导致整个进程崩溃
      - 进程关闭时操作系统会回收这部分内存

- 浏览器架构
   - 多进程架构优点：提升了稳定性，安全性，流畅性；缺点：更高的资源占用，每个渲染进程中都有V8引擎；更复杂的体系结构，各个模块耦合性较高；
   - 浏览器主进程
   用户交互、子进程管理、存储等功能
   - 渲染进程
   用于将CSS、HTML转换为浏览器可识别的模样，排版引擎和JS V8引擎都在渲染进程中，每打开一个Tab页都会创建一个新的渲染进程，同一站点（根域名（例如，geekbang.org）加上协议（例如，https:// 或者http://）相同）除外，
   - 插件进程
   用于运行插件，由于插件易崩溃，防止影响主进程而增加的进程
   - 网络进程
   用于网络资源加载
   - GPU进程
   用于绘制页面 

- 浏览器渲染过程
   - 构建DOM树
      - 将html转化为浏览器能够识别的树形结构，可通过JS读写
   - 样式计算：为DOM树所有元素添加对应的CSS样式
      - 将CSS转化为能够识别的styleSheet
      - 将属性值标准化，比如应用了em，rem等，red等
      - 根据继承和层叠为每个DOM节点对应CSS样式，生成computedStyle
   - 布局阶段：计算出DOM元素的几何位置
      - 额外创建一个只包含DOM中可见元素的布局树LayoutTree
      - 布局计算，几何位置计算
   - 分层
      - 为了3D动画，层叠效果（z-index、透明度、position属性、截取文本）等，对布局树进行分层生成LayerTree
   - 图层绘制
      - 为图层生成绘制列表（把图层绘制分步形成列表），提交给合成线程
   - 栅格化
      - 合成线程将图层分为图块，先渲染视口附近，将视口附近的图块交给珊格线程池（加快首屏显示）
      - 珊格线程池将图块转为位图（点阵图像，由像素点组成），位图交给合成线程，都转化完合成线程会提交给浏览器进程
   - 合成与显示
      - 浏览器进程生成页面存于内存中发给显卡，显示

- 重绘和回流
   - 回流
   修改了DOM元素的几何属性，渲染流程都需重新运行一遍，开销较大
      - width、height、padding、margin、left、top、border等几何属性
      - 使DOM元素移动或增减
      - 读写 offset族、scroll族和client族属性的时候，浏览器为了获取这些值，需要进行回流操作。
      - 调用 window.getComputedStyle 方法
   - 重绘
   修改的属性不会使DOM几何属性变化，渲染流程跳过布局和分层的阶段直接进入图层绘制阶段
      - color

- 浏览器事件循环

- 垃圾回收

- 从输入URL到显示界面都发生了什么
   - DNS解析
   - TLS握手
   - TCP/IP握手
   - http请求
   - 将获取的页面渲染
   
### Http/Https
- cookie
   - cookie是存储在客户端的一小块数据，http是无状态的，cookie的作用就是维护状态，让服务器知道两次请求来自同一个客户端；cookie是在第一次请求中由服务端放在响应头的setCookie字段中，浏览器收到会将其缓存，下次请求时会自动带着cookie表明身份；
   - cookie的属性，以建值对的形式存储，name: value; domain: 域名; path: 路径; secure: true只会在安全协议中; Expires/Max-age: 过期时间/存活秒数; httpOnly: 是否可用JS获取修改cookie;
   - cookie缺陷
      - 容量：大小只有4KB
      - 性能：若不设置路径的情况下，访问相同域名都会带上cookie，造成不必要的资源浪费
      - 安全：以纯文本形式传输，容易被截取恶意携带cookie向服务器发送请求 XSS攻击；可被JS读写

- 跨域
   - 由于浏览器的同源策略（协议主机和端口均相同），向不同源的服务器发送请求会造成跨域，该请求发出后，服务器会作出响应，但如果响应头中没有CORS字段，浏览器会把响应废弃；
   - 解决办法
      - JSONP
         - 虽然XMLHttpRequest对象遵循同源政策，但是script标签不一样，它可以通过 src 填上目标地址从而发出 GET 请求，实现跨域请求并拿到响应。
         将get和回调函数拼接放入src属性中发出get请求，服务端将返回数据放入回调函数入参中即可，客户端收到响应指向回调函数拿到数据；
      - CORS（跨域资源共享）
         - 浏览器发出请求时会添加Origin字段，服务器拿到请求之后，在回应时对应地添加Access-Control-Allow-Origin字段，
         如果Origin不在这个字段的范围中，那么浏览器就会将响应拦截。
      - Nginx反向代理
         - 比如客户端为client.com，服务器为server.com，客户端向服务器请求访问 server.com/api，Nginx 相当于起了一个跳板机，
         这个跳板机的域名也是client.com，让客户端首先访问 client.com/api，这当然没有跨域，然后 Nginx 服务器作为反向代理，
         将请求转发给server.com，当响应返回时又将响应给到客户端，这就完成整个跨域请求的过程。
         
- 常见状态码
   - 1xx: 接受，继续处理
   - 200: 成功，并返回数据
   - 201: 已创建
   - 202: 已接受
   - 203: 成功，但未授权
   - 204: 成功，无内容
   - 205: 成功，重置内容
   - 206: 成功，部分内容
   - 301: 永久移动，重定向
   - 302: 临时移动，可使用原有URI
   - 304: 资源未修改，可使用缓存
   - 305: 需代理访问
   - 400: 请求语法错误
   - 401: 要求身份认证
   - 403: 拒绝请求
   - 404: 资源不存在
   - 500: 服务器错误

- get/post区别
   - get请求在url中，post在请求体中，导致get请求不安全
   - get请求有缓存，post请求没有
   - 浏览器后退时get请求不会重新发送，post会
   - get请求受url长度限制，post不会
   
- TLS握手（http和tcp的中间层SSL）
   - 客户端生成随机数client_random以及加密套件发送给服务端
   - 服务端返回确定的加密算法以及证书和随机数server_random
   - 客户端解析证书确认身份同时获取公钥，生成随机数pre_random，将随机数用公钥加密，用三个随机数得出密钥
   - 服务端用私钥解密得到pre_random，同时用三个随机数生成密钥

- http缓存（分为浏览器直接判断的强缓存和发送http请求让服务端判断的协商缓存）
   - 强缓存
      - 首先是检查强缓存，这个过程不需要发送http请求。http/1.0当中靠Expires来检查，Expires存在于服务端响应头中，标明了缓存的过期时间。
      当浏览器要继续发送该请求时会对比当前时间和过期时间，没过期命中，过期了发送http请求进入协商缓存阶段（缺陷，服务端和客户端时间有可能不同）。
      http/1.1当中使用Cache-control来判断，也存在于响应头当中，使用max-age字段标明了缓存的存活时间，秒为单位，表示未来的多长时间可以使用缓存。
      过期进入协商缓存。
   - 协商缓存
      - 强缓存失效后，浏览器发送http请求时会携带相应的缓存标签用来给服务端判断是否命中协商缓存。缓存标签分为两种。
         - Last-Modified：
            即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。
            浏览器接收到后，如果再次请求，会在请求头中携带If-Modified-Since字段，这个字段的值也就是服务器传来的最后修改时间。
            服务器拿到请求头中的If-Modified-Since的字段后，其实会和这个服务器中该资源的最后修改时间对比:如果请求头中的这个值小于最后修改时间，
            说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。否则返回304，告诉浏览器直接用缓存。
         - ETag：
            服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。
            服务器通过响应头把这个值给浏览器。浏览器接收到ETag的值，会在下次请求时，将这个值作为If-None-Match这个字段的内容，并放到请求头中，
            然后发给服务器。服务器接收到If-None-Match后，会跟服务器上该资源的ETag进行比对:如果两者不一样，说明要更新了。
            返回新的资源，跟常规的HTTP请求响应的流程一样。否则返回304，告诉浏览器直接用缓存。
   
- http2有何改进
- 网络模型

### Tcp/Ip
- UDP和TCP区别
UDP是面向无连接的传输层协议，有不可靠性；不会对数据进行备份和排序，不管数据是否有序到达接收方，也没有流量控制和拥塞处理算法，导致在网络环境不好的情况下容易丢包；但是这也体现了UDP轻便的特点，在需要实时传输的场景有很好的应用，比如网络直播网络游戏等；
TCP是面向连接的传输层协议，通过超时重传协议保证了数据的完整性；流量控制和拥塞处理算法解决了网络拥塞问题，能保证在不同网络环境下稳定传输；但保证稳定的同时也就丢失了一些实时性；

- TCP怎么保证数据完整到达接收方
通过超时重传协议（ARQ）；
   - 停止等待ARQ：当发送方发出报文时会打开一个定时器，在定时器结束之前收到接收方应答就是正常；如果未收到就会重传之前的报文；如果确认报文丢失，发送方会继续发送，接收方会丢弃这段报文等待新报文的接收；（定时器的设置会大于一个RTT从发出报文到接收到对端确认报文的时间）
   - 连续ARQ：发送方会维持一个发送窗口，在窗口范围内连续分组发送数据，接收方不会连续确认，而是过一段时间后，将接收到的数据中按序到达的最后一个分组确认，发送方每收到一次确认就往前滑动一个分组；

- 三次握手（为什么三次握手，什么是半连接队列，握手过程可以传输数据吗，什么是SYN攻击）
   - 三次握手过程
      - 双方都是Close状态，客户端发送SYN包请求连接（包含SYN=1，初始序列号seq=x，确认为ACK为0）进入SYN_send状态
      - 服务端收到连接请求，将连接放入半连接队列中，回复SYN+ACK确认包（SYN=1，确认位ACK=1，初始序列号seq=y，确认序列号ack=x+1）进入SYN_Received状态
      - 客户端收到确认，回复ACK确认包（ACK=1，ack=y+1，seq=x+1（第一次消耗一个序列号）），进入established状态，服务端收到客户端确认包后也会进入ESTABLISHED状态，并把连接放入全连接队列。
   - 为什么三次握手
   确认双方收发能力正常，同时为了避免因网络状况造成的服务端资源浪费问题，场景为客户端超时请求连接报文被服务端接收，服务器再次进入ESTABLISHED状态，而此时客户端已经CLOSE，服务端一直等待客户端数据，造成资源浪费
   - 什么是半连接队列
   存放客户端IP地址，第一次握成功的客户端IP地址
   - SYN攻击
   使用伪造IP地址一直给服务端发送连接请求导致服务端半连接队列爆满，造成服务端一直给假IP发送确认包，造成资源浪费，也使真正的请求无法被接收；解决方法可以增大半连接队列，减少重传次数；

- 四次挥手（为什么四次握手）
   - 四次挥手过程
      - 客户端向服务端发送FIN断开请求（FIN=1，ACK=0，seq=x）进入FIN_WAIT1状态 
      - 服务端接收到，发送确认断开包（ACK=1，ack=x+1），进入CLOSE_WAIT状态；表明此时a到b的连接已断开，不会再接受a的数据，但此时服务端可能仍有数据要发送
      - 服务端数据发送完毕也要断开连接了，给客户端发送断开请求包（FIN=1，ACK=0，seq=y）进入LAST_ASK状态
      - 客户端收到，发送确认包（ACK=1，ack=y+1），进入FIN_WAIT2状态，等到2MSL（报文最大存活时间，确保服务端收到自己的确认，如果未收到就断开连接，服务端会一直等待客户端的确认，导致服务端不能正常关闭）后进入CLOSE状态，服务端收到后进入CLOSE状态；
   - 为什么四次挥手
   服务端可能未发送完数据，等等发送完才能断开连接

- 流量控制和拥塞处理
   - 流量控制
      - 滑动窗口（解决丢包，数据不对以及流量控制的问题）
      TCP中发送端和接收端各维护着一个窗口，发送窗口和接收窗口，发送窗口包含已发送但未得到确认的数据和可以发送但未发送的数据；发送窗口的大小
是由接收方接收窗口的剩余大小决定的；接收方会把窗口剩余大小放入应答包中发送给发送方，发送方根据大小以及网络情况确定发送窗口的大小；这样确保了接收方能够接收到数据，避免了接收方带宽已满但发送方仍在发送的问题；接收方为0窗口时，发送方会设定定时器，定时询问接收方窗口大小，若超过一定次数会中断TCP连接；
拥塞处理（防止过多数据拥塞网络，保证长时间稳定的在不同网络环境中较好的传输数据）
   - 拥塞处理（解决网络问题）
      - 慢启动
         1. 将发送窗口设为1MSS（1分段最大数据量）
         2. 每过一个RTT将窗口大小乘2
         3. 有一个阀值限制，超过阀值启动拥塞避免算法
      - 拥塞避免：每过一个RTT把窗口大小+1，当定时器时间到了没收到确认包时统一认定是网络拥塞问题，进行如下处理
         1. 将阀值设置为当时窗口的一半
         2. 发送窗口设置为1MSS
         3. 启动拥塞避免算法
      - 快速重传
         - 当报文失序时，接收方会发送最后一个有序的序号作为应答，当发送端收到三个相同的ACK时，不等待定时器结束，立即重传之前报文；
         - TCP Reno
            1. 发送窗口减半
            2. 阀值设置为当前拥塞窗口
            3. 进入快恢复阶段（重发对端需要的包，一旦收到一个新的 ACK 答复就退出该阶段），这种方式在丢失多个包的情况下就不那么好了
            4. 启动拥塞避免算法
         - TCP New Ren 改进后的快恢复
            TCP New Reno 算法改进了之前 TCP Reno 算法的缺陷。在之前，快恢复中只要收到一个新的 ACK 包，就会退出快恢复。
               在 TCP New Reno 中，TCP 发送方先记下三个重复 ACK 的分段的最大序号。
            假如我有一个分段数据是 1 ~ 10 这十个序号的报文，其中丢失了序号为 3 和 7 的报文，那么该分段的最大序号就是 10。
            发送端只会收到 ACK 序号为 3 的应答。这时候重发序号为 3 的报文，接收方顺利接收的话就会发送 ACK 序号为 7 的应答。
            这时候 TCP 知道对端是有多个包未收到，会继续发送序号为 7 的报文，接收方顺利接收并会发送 ACK 序号为 11 的应答，
            这时发送端认为这个分段接收端已经顺利接收，接下来会退出快恢复阶段。

### 第一轮面试问题总结
   - SEO
      - SEO是搜索引擎优化，目的是使网站在搜索引擎中排名上升，提高权重，同时也优化了用户体验，增加用户量；
      - 实现方向
         1. 优化网站结构
            - 控制首页链接：要有各个功能的内部链接便于爬虫跳转，但无用链接要减少，会降低用户体验；
            - 目录扁平化：尽量层次不要超过3级，用户一般跳转三次没有得到想要的结果就会离开网站；
            - 利用布局主要内容放在前面：例如三栏布局，将中间栏写在html的最上面，左右两栏利用浮动，写在下面；
            - 增加导航：导航尽量使用文字，若用图片导航应添加alt（网络不好的情况下图片展示的文字）和title标签描述图片；尽量在每个页面
            增加面包屑导航，不仅可以让爬虫方便明确结构，大量的内部链接使其方便抓取，降低跳出率。也可使用户体验提升，了解网站结构，提供的跳转接口也便于操作；
            - 控制大小：过大容易造成加载时间过长，导致爬虫放弃爬取，用户体验也较差；
         2. 优化代码
            - 合理设计description、keyword、title属性；关键词要准确但不能胡乱堆砌；
            - 标签语义化，使用对应标签描述对应内容，合理使用h1-h6，nav等标签，让阅读者和爬虫一目了然；
            - <a>标签对于内部链接要增加title描述，外部链接要增加rel=nofollow,因为爬出去就不会回来了；
            - <img>标签要添加alt和title描述；
            - 使用强调标签，<strong><em>它们有强调作用，将关键字放入会引起搜索引擎的高度注意，<b><i>只是显示效果，对seo没有作用；
            - 重要代码不要放在js中，爬虫不理解js，要放在html中；
            - display: none要谨慎使用，其中的内容会被爬虫舍弃；
         3. 提升网站性能
            - 使用CDN缓存
               - 使用CDN可以减轻服务器压力，加快请求速度；
            - GZIP压缩
               - 可显著提升请求效率，需服务器配置；
            - 雪碧图
               - 用一张大图包含所有小图，减少http请求次数，利用css的background属性使用雪碧图
            - 懒加载
               - 只加载视口部分的列表，待用户滚动到视口三分之二再加载下一部分列表；
            - 减少回流
               回流会触发整个渲染流程，开销较大；可通过以下方式避免；
               - 减少修改元素几何属性，height、width、left、margin、padding等
               - 减少对dom元素的移动和增减
               - 减少对scroll属性的获取
               - 避免获取computedStyle 
            - 减少dom操作
               - dom操作比较耗费性能，减少dom操作可以有效提高性能；
            - 利用浏览器缓存
               - 不经常变化的文件可利用浏览器缓存，减少请求次数，优化加载速度；
         4. 总结
         了解SEO，但不过分SEO，还是以网站内容为主；另外现在主流的都是单页面应用，对SEO没有作用，需要使用SSR（服务端渲染）
         
   - 前端模块化

   - 服务端渲染

   - webpack配置
   一般配置两个文件，一个是生产环境，一个是开发环境；在开发环境中配置热更新，解析css、sass、图片等；在生成环境配置文件指纹以及代码压缩和文件解析；在package.json中script属性中配置，dev对应开发打包，build对应生产打包
      - 热更新
      使用webpack-dev-server以及webpack自带的热更新插件，初次运行它会起一个本地node服务，在浏览器中与服务建立联系，当触发热更新打包时会将新文件发送给浏览器，进行页面更新；
      - 文件指纹
         - hash
         作用于项目，每次项目更新都会更新hash，一般图片用这种方式
         - chunkhash
         作用于chunk，每个entry是一个chunk，这个模块更新了就会更新chunkhash，一般用于js文件
         - contenthash
         作用于内容，内容改变时会触发contenthash，一般css文件使用，借助于MiniCssExtractPlugin插件，注意的地方在于与style-loader冲突，style会将打包好的css直接放入html的head标签中，不会创建css文件，而MiniCssExtractPlugin会创建css文件，进行打包
